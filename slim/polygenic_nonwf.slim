function (float)ssh(object pop, object mut_type) {
  x = sim.mutationFrequencies(pop, sim.mutationsOfType(mut_type));
  return 2*sum(x * (1-x));
}

function (void)assert(logical x, [string msg = "assertion failed"]) {
  if (!x) stop(msg);
}

function (logical)contains(string x, string y) {
  assert(length(x) == 1 & length(y) == 1, "x and y must be length 1");
  return length(strsplit(x, y)) > 1;
}

function (string)filename_str(string params) {
  out = "";
  for (i in seqAlong(params)) {
    v = params[i];
    val = executeLambda(v + ";");
    assert(!contains(asString(val), "..") & !contains(asString(val), "/"),
           "filename key/value cannot contain . or /!");
    out = out + v + val + "_";
  }
  return out;
}

function (object)param_dict(string params) {
  pd = Dictionary();
  for (i in seqAlong(params)) {
    v = params[i];
    val = executeLambda(v + ";");
    if (length(val) > 1) {
      val = paste(val, sep=",");
    }
    pd.setValue(v, val);
  }
  return pd;
}

initialize() {
  initializeSLiMModelType("nonWF");
  defineConstant("region_length", 100e6);
  defineConstant("seed", getSeed());

  if (exists("slimgui") | (exists("defaults"))) {
    // default command line arguments; primarily for debugging.
    defineConstant("rep", 0);
    defineConstant("Vs", 1);
    defineConstant("K", 500);
    defineConstant("rbp", 1e-8);
    defineConstant("alpha", 0.01);
    defineConstant("muT", 1e-8);
    defineConstant("muN", 1e-8);
    //defineConstant("muD", 1 / (2 * region_length));
    defineConstant("muD", 0);
    defineConstant("h", 0.5);
    defineConstant("s", 1e-2);
    defineConstant("a", 0.01); // alpha in epistasis model
    defineConstant("b", 0.01); // beta in epistasis model
    defineConstant("fitfunc", "shift");
    defineConstant("optimasd", 0.5*sqrt(Vs));
    defineConstant("optimabm", F);
 	defineConstant("datadir", '');
  } else {
	 defineConstant("datadir", '../data/slim_sims/polygenic_nonwf/');
  }
  defineConstant("burnin", 10*K);
  defineConstant("rungen", 10*K);
  defineConstant("end", burnin + rungen);
  defineConstant("shift_generation", burnin);
  defineConstant("fitness_offset", 0.0);

  initializeSLiMOptions(keepPedigrees=T);
  // initializeTreeSeq();

  // mutations
  initializeMutationRate(muD + muN + muT);
  initializeMutationType("m1", 0.5, "s", "if (runif(1) < 0.5) -alpha; else alpha;");
  m1.convertToSubstitution = T;
  initializeMutationType("m2", 0.5, "f", 0.0);
  m2.convertToSubstitution = T;
  initializeMutationType("m3", h, "f", s);
  m3.convertToSubstitution = T;

   // genomic region
  initializeGenomicElementType("g1", c(m1, m2, m3), c(muT, muN, muD));
  initializeGenomicElement(g1, 0, region_length-1);

  // recombination
  initializeRecombinationRate(rbp);

  defineConstant("basename", "polygenic_nonwf_" + 
    filename_str(c('rep', 'Vs', 'fitfunc', 'optimasd', 'optimabm', 'K', 'alpha', 
                   's', 'h', 'muT', 'muN', 'muD', 'rbp')));
  // defineConstant("treeseq_file", datadir + basename + "treeseq.tree");
  defineConstant("log_file", datadir + basename + "log.tsv.gz");
}

reproduction() {
  subpop.addCrossed(individual, subpop.sampleIndividuals(1));
}

fitness(m1) {
  return 1.0;
}

fitness(m3) {
  // these have no fitness effects directly because 
  // we need to impose this through a synergistic epistasis
  // function
  return 1.0;
}

// fitness(NULL) {
//   if (fitfunc == 'moving' | fitfunc == 'shift') {
//     optima = sim.getValue('optima');
//     traitfit = dnorm(individual.tagF - optima, mean=0.0, sd=sqrt(Vs));
//     delmuts1 = individual.genome1.mutationCountsInGenomes(sim.mutationsOfType(m3));
//     delmuts2 = individual.genome2.mutationCountsInGenomes(sim.mutationsOfType(m3));
//     delmuts = delmuts1 + delmuts2;
//     ndelsubs = 2*sum(sim.substitutions.mutationType == m3); // 2x for diploidy
//     nhets = sum(delmuts == 1);
//     nhoms = sum(delmuts == 2);
//     delfit = (1 - h*s)^nhets * (1 - s)^nhoms * (1-s)^ndelsubs;
//     fitn = fitness_offset + traitfit * delfit / dnorm(0.0, mean=0.0, sd=sqrt(Vs));
//     return fitn;
//   }
// }

1 early() {
  sim.addSubpop("p1", asInteger(0.1*K));
  sim.rescheduleScriptBlock(s1, start=2, end=end);
  sim.rescheduleScriptBlock(s2, start=end, end=end);

  // initialize optima
  sim.setValue('optima', 0.);

  pd = param_dict(c('rep', 'Vs', 'fitfunc', 'optimasd', 'optimabm', 'K', 'alpha', 
                    's', 'h', 'muT', 'muN', 'muD', 'rbp', 'end'));
  log = sim.createLogFile(log_file, initialContents="#" + pd.serialize(), compress=T, sep="\t", logInterval=1);
  log.addGeneration();
  inds = sim.subpopulations.individuals;
  log.addMeanSDColumns('z', 'sim.subpopulations.individuals.tagF;');
  log.addCustomColumn('optima', 'sim.getValue("optima");');
  log.addCustomColumn('N', 'p1.individualCount;');
  log.addMeanSDColumns('nmutT', 'sim.subpopulations.individuals.countOfMutationsOfType(m1);');
  log.addMeanSDColumns('nmutN', 'sim.subpopulations.individuals.countOfMutationsOfType(m2);');
  log.addMeanSDColumns('nmutD', 'sim.subpopulations.individuals.countOfMutationsOfType(m3);');
  log.addCustomColumn('sshT', 'ssh(p1, m1);');
  log.addCustomColumn('sshN', 'ssh(p1, m2);');
  log.addCustomColumn('sshD', 'ssh(p1, m3);');
  log.addCustomColumn('nfixed_dels', '2*sum(sim.substitutions.mutationType == m3);');
  log.addCustomColumn('fixed_load', '(1-s)^(2*sum(sim.substitutions.mutationType == m3));');
  log.addCustomColumn('fixed_trait', '2*sum(sim.substitutions.selectionCoeff*asInteger(sim.substitutions.mutationType == m1));');
  log.addCustomColumn('Ne', 'sim.getValue("Ne");');
  log.addMeanSDColumns('repr', 'sim.subpopulations.individuals.reproductiveOutput;');
}

s1 early() {
  //print(sim.generation);
  inds = sim.subpopulations.individuals;
  if (sim.generation > shift_generation) {
    // remember individuals before the optima shift
    if (fitfunc == 'moving') {
      // optima evolution as BM
      optima0 = sim.getValue('optima');
      if (optimabm) {
        shift = rnorm(1, 0, optimasd*sqrt(Vs));
      } else {
        shift = optimasd*sqrt(Vs);
      }
      optima = optima0 + shift;
      sim.setValue('optima', optima);
    } else if (fitfunc == 'shift') {
      optima0 = sim.getValue('optima');
      optima = optimasd * sqrt(Vs);
      sim.setValue('optima', optima);
    }
  }

  phenotypes = inds.sumOfMutationsOfType(m1);
  // fixed trait effects
  fixed_trait = 2 * sum(sim.substitutions.selectionCoeff * asInteger(sim.substitutions.mutationType == m1));
  inds.tagF = phenotypes; //+ fixed_trait;

  // a faster way to calculate fitness
  optima = sim.getValue('optima');

  // synergistic epistasis load
  nmuts = inds.sumOfMutationsOfType(m3);
  del_fitness = exp(- (a * nmuts + 0.5 * b^2));

  // we need to factor in the fixed load, since mutations
  // are converted to substitutions
  ndelsubs = 2*sum(sim.substitutions.mutationType == m3); // 2x for diploidy
  inds.fitnessScaling = dnorm(phenotypes + fixed_trait - optima, mean=0.0, sd=sqrt(Vs)) * (1-s)^ndelsubs;

  // mutation tracking for Ne on-the-fly calculation
  if (sim.generation > 1) {
    muts = sim.getValue('last_gen_muts');
    f0 = sim.getValue('last_gen_freqs');
    f1 = sim.mutationFrequencies(p1, muts);
    if (length(f0) > 0) {
      // Ne = 0.5 * mean(f0 * (1-f0)) / var(f0 - f1);
      Ne = 0.5 * var(f0 * (1-f0) / (f0 - f1));
      sim.setValue("Ne", Ne);
    }
  } else {
    sim.setValue("Ne", 0);
  }
  muts = sim.mutationsOfType(m2);
  if (length(muts) > 1000) {
    muts = sample(muts, 1000);
  }
  sim.setValue('last_gen_muts', muts);
  sim.setValue('last_gen_freqs', sim.mutationFrequencies(p1, muts));

}

// density-dependent selection
early() {
  p1.fitnessScaling = K / p1.individualCount;
}

late() {
  if (p1.individualCount == 0) {
    // sim.treeSeqOutput(reeseq_file);
    sim.simulationFinished();
  }
}

s2 late() {
  // sim.treeSeqOutput(treeseq_file);
  sim.simulationFinished();
}
